# Skill: USB HID Keyboard Driver
# Pattern extracted from: drivers/hid/usbhid/usbkbd.c
# Purpose: Document transpilation patterns for USB input device drivers

## METADATA
skill_name: "usb_hid_keyboard"
skill_version: "1.0"
source_driver: "drivers/hid/usbhid/usbkbd.c"
kernel_version: "6.6.70"
complexity: "simple"
dependencies: ["usb_core", "input_subsystem"]
config_options: ["CONFIG_USB_HID", "CONFIG_HID", "CONFIG_INPUT"]

## DRIVER STRUCTURE

The USB HID keyboard driver follows the standard USB driver pattern:

1. **Device Structure** - State container
   - Input device reference (input_dev)
   - USB device reference (usb_device)
   - URB (USB Request Block) for interrupt transfers
   - Keycode lookup table
   - LED state management

2. **USB Callbacks** - Lifecycle hooks
   - probe()   - Device attachment
   - disconnect() - Device removal
   - irq()     - Interrupt handler (keypress/release)

3. **Input Events** - Kernel subsystem integration
   - input_report_key() - Report key press/release
   - input_sync()       - Synchronize event batch

## KEY PATTERNS FOR TRANSPILATION

### Pattern 1: Lookup Tables (Static Data)
**C Pattern:**
```c
static const unsigned char usb_kbd_keycode[256] = {
      0,  0,  0,  0, 30, 48, 46, 32, 18, 33, ...
};
```

**Zig Equivalent:**
```zig
const usb_kbd_keycode: [256]u8 = .{
    0, 0, 0, 0, 30, 48, 46, 32, 18, 33, ...
};
```

**Pattern Notes:**
- Direct array initialization translates cleanly
- Zig has stronger type safety (u8 vs unsigned char)
- Const correctness enforced at compile time

### Pattern 2: Device State Struct
**C Pattern:**
```c
struct usb_kbd {
    struct input_dev *dev;
    struct usb_device *usbdev;
    unsigned char old[8];
    struct urb *irq, *led;
    spinlock_t leds_lock;
    bool led_urb_submitted;
};
```

**Zig Equivalent:**
```zig
const UsbKeyboard = struct {
    dev: *InputDev,
    usbdev: *UsbDevice,
    old: [8]u8,
    irq: *Urb,
    led: *Urb,
    leds_lock: Spinlock,
    led_urb_submitted: bool,
};
```

**Pattern Notes:**
- Pointers map directly (* in both)
- Fixed-size arrays [N]T in Zig vs Type[N] in C
- Naming: PascalCase for types in Zig, snake_case for C structs
- Zig enforces non-null by default, use ?*T for nullable pointers

### Pattern 3: URB Interrupt Handler
**C Pattern:**
```c
static void usb_kbd_irq(struct urb *urb)
{
    struct usb_kbd *kbd = urb->context;

    switch (urb->status) {
    case 0:  /* success */
        break;
    case -ECONNRESET:
    case -ENOENT:
    case -ESHUTDOWN:
        return;
    default:
        goto resubmit;
    }

    // Process key events
    for (i = 0; i < 8; i++)
        input_report_key(kbd->dev,
                        usb_kbd_keycode[i + 224],
                        (kbd->new[0] >> i) & 1);

    // Compare old/new state for key changes
    memcpy(kbd->old, kbd->new, 8);

resubmit:
    usb_submit_urb(urb, GFP_ATOMIC);
}
```

**Zig Equivalent:**
```zig
fn usbKbdIrq(urb: *Urb) void {
    const kbd = @ptrCast(*UsbKeyboard, @alignCast(@alignOf(UsbKeyboard), urb.context));

    switch (urb.status) {
        0 => {}, // success
        -ECONNRESET, -ENOENT, -ESHUTDOWN => return,
        else => {
            // resubmit
            _ = usb.submitUrb(urb, .GFP_ATOMIC) catch |err| {
                log.err("URB resubmit failed: {}", .{err});
            };
            return;
        },
    }

    // Process key events
    for (0..8) |i| {
        inputReportKey(
            kbd.dev,
            usb_kbd_keycode[i + 224],
            (kbd.new[0] >> @intCast(u3, i)) & 1 == 1
        );
    }

    // Compare old/new state
    @memcpy(kbd.old[0..], kbd.new[0..8]);

    // Resubmit URB
    usb.submitUrb(urb, .GFP_ATOMIC) catch |err| {
        log.err("URB resubmit failed: {}", .{err});
    };
}
```

**Pattern Notes:**
- Error handling: Zig uses explicit catch, C uses return codes
- Casting: @ptrCast/@alignCast in Zig vs simple cast in C
- Loops: for (0..N) in Zig vs for (i = 0; i < N; i++) in C
- Memory ops: @memcpy in Zig vs memcpy in C
- No goto in Zig - use explicit control flow
- Bit operations require explicit integer types (@intCast)

### Pattern 4: USB Device ID Table
**C Pattern:**
```c
static const struct usb_device_id usb_kbd_id_table[] = {
    { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID,
                         USB_INTERFACE_SUBCLASS_BOOT,
                         USB_INTERFACE_PROTOCOL_KEYBOARD) },
    { }  /* Terminating entry */
};
MODULE_DEVICE_TABLE(usb, usb_kbd_id_table);
```

**Zig Equivalent:**
```zig
const usb_kbd_id_table = [_]UsbDeviceId{
    UsbDeviceId.initInterfaceInfo(
        .USB_INTERFACE_CLASS_HID,
        .USB_INTERFACE_SUBCLASS_BOOT,
        .USB_INTERFACE_PROTOCOL_KEYBOARD
    ),
};

export const __mod_usb__usb_kbd_id_table_device_table
    linksection(".modinfo") = usb_kbd_id_table;
```

**Pattern Notes:**
- Array initialization: [_] for type inference in Zig
- No sentinel/terminating entry needed in Zig (length encoded in type)
- Module macros (MODULE_DEVICE_TABLE) → export + linksection

## TRANSPILATION CHECKLIST

When converting USB input drivers to Zig:

- [ ] Replace `struct` definitions with Zig struct types
- [ ] Convert pointer types (`*` in C → `*` or `?*` in Zig)
- [ ] Replace fixed arrays (Type[N] → [N]Type)
- [ ] Convert callbacks to Zig functions (camelCase naming)
- [ ] Replace `switch` with error handling via catch/try
- [ ] Convert for loops to Zig range syntax
- [ ] Replace memory functions (memcpy → @memcpy, etc.)
- [ ] Add explicit integer casts for bit operations
- [ ] Remove goto, use explicit blocks/returns
- [ ] Convert MODULE_* macros to export + linksection
- [ ] Add safety checks (null checks, bounds checks)
- [ ] Replace spinlocks with Zig mutexes/atomics

## EXAMPLE: Minimal USB Keyboard Driver in Zig

```zig
const std = @import("std");
const usb = @import("kernel/usb.zig");
const input = @import("kernel/input.zig");

const UsbKeyboard = struct {
    dev: *input.InputDev,
    usbdev: *usb.UsbDevice,
    old: [8]u8,
    new: [8]u8,
    irq_urb: *usb.Urb,

    pub fn init(dev: *usb.UsbDevice, intf: *usb.UsbInterface) !*UsbKeyboard {
        const kbd = try usb.allocator.create(UsbKeyboard);
        kbd.* = .{
            .dev = try input.allocInputDev(),
            .usbdev = dev,
            .old = [_]u8{0} ** 8,
            .new = [_]u8{0} ** 8,
            .irq_urb = try usb.allocUrb(0, .GFP_KERNEL),
        };

        // Setup input device
        kbd.dev.name = "USB Keyboard";
        kbd.dev.dev.parent = &intf.dev;

        // Setup URB
        const endpoint = intf.cur_altsetting.endpoint[0];
        usb.fillIntUrb(
            kbd.irq_urb,
            dev,
            usb.rcvIntPipe(dev, endpoint.bEndpointAddress),
            &kbd.new,
            8,
            usbKbdIrq,
            kbd,
            endpoint.bInterval
        );

        try input.registerDevice(kbd.dev);
        try usb.submitUrb(kbd.irq_urb, .GFP_KERNEL);

        return kbd;
    }

    pub fn deinit(kbd: *UsbKeyboard) void {
        usb.killUrb(kbd.irq_urb);
        input.unregisterDevice(kbd.dev);
        usb.freeUrb(kbd.irq_urb);
        usb.allocator.destroy(kbd);
    }
};

fn usbKbdIrq(urb: *usb.Urb) callconv(.C) void {
    const kbd = @ptrCast(*UsbKeyboard, @alignCast(@alignOf(UsbKeyboard), urb.context));

    if (urb.status != 0) {
        _ = usb.submitUrb(urb, .GFP_ATOMIC) catch return;
        return;
    }

    // Report modifier keys
    for (0..8) |i| {
        const pressed = (kbd.new[0] >> @intCast(u3, i)) & 1 == 1;
        input.reportKey(kbd.dev, usb_kbd_keycode[i + 224], pressed);
    }

    // Detect key changes
    for (kbd.old[2..8], 2..) |old_key, i| {
        if (old_key > 3 and !std.mem.containsAtLeast(u8, kbd.new[2..8], 1, &[_]u8{old_key})) {
            input.reportKey(kbd.dev, usb_kbd_keycode[old_key], false);
        }

        const new_key = kbd.new[i];
        if (new_key > 3 and !std.mem.containsAtLeast(u8, kbd.old[2..8], 1, &[_]u8{new_key})) {
            input.reportKey(kbd.dev, usb_kbd_keycode[new_key], true);
        }
    }

    input.sync(kbd.dev);
    @memcpy(kbd.old[0..], kbd.new[0..8]);

    _ = usb.submitUrb(urb, .GFP_ATOMIC) catch {};
}

// Driver registration
export const usb_kbd_driver = usb.UsbDriver{
    .name = "usbkbd",
    .probe = usbKbdProbe,
    .disconnect = usbKbdDisconnect,
    .id_table = &usb_kbd_id_table,
};
```

## AUTOMATION TARGETS FOR ALCHEMIST

The Alchemist should automate these conversions:

1. **Struct transpilation**: C struct → Zig struct (90% automated)
2. **Pointer conversion**: Detect nullable vs non-null patterns
3. **Array translation**: Fixed-size array detection
4. **Error handling injection**: Insert try/catch around USB/input calls
5. **Loop modernization**: C for → Zig range loops
6. **Memory safety**: Add bounds checks, null checks
7. **Callback signatures**: Ensure callconv(.C) for kernel callbacks

## VALIDATION TESTS

To verify transpilation correctness:

- [ ] Compile test: Zig code compiles without errors
- [ ] Type safety: All pointer types correctly annotated
- [ ] Memory safety: No buffer overflows, null dereferences
- [ ] Functional test: Driver detects keypresses in QEMU
- [ ] Performance: No measurable overhead vs C version

---
Generated by: Manual analysis
Date: 2026-01-03
Next: Document USB mass storage driver pattern
